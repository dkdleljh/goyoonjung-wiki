#!/usr/bin/env python3
"""Apply alternative proof candidates into markdown files.

Input
- data/alternative_proofs.json (generated by scripts/suggest_alternative_proofs.py)

Goal
- For links on skipped/blocked domains, add *additional* accessible URLs as alternative proofs.

Rules (safety)
- Never remove or rewrite the original skipped URL.
- Never fetch the web.
- Only insert alternatives that are already present in the same file (suggestion source).
- Avoid duplicate insertion.

Insertion strategy
1) If the skipped URL appears inside a structured entry block (common wiki templates):
   - Find the line containing the skipped URL.
   - Insert a new line immediately after it:
       - 대체 근거(열리는 링크): <url1>, <url2>, ...
   - Only if a similar line doesn't already exist nearby.
2) Otherwise, append an HTML comment on the same line:
       <!-- ALT-PROOF: url1 | url2 -->

The structured-entry heuristic looks for an entry block started by lines like:
- 날짜:, - 매체:, - 구분:, - 제목:, - 링크:, - 링크(원문):, - 링크(공식/원문):

"""

from __future__ import annotations

import json
import re
from dataclasses import dataclass
from pathlib import Path

BASE = Path(__file__).resolve().parent.parent
DATA = BASE / "data" / "alternative_proofs.json"

ENTRY_START_RE = re.compile(r"^\s*-\s*(날짜|매체|구분|종류|제목|링크|링크\(원문\)|링크\(공식/원문\)|링크\(공식\)|프로그램/행사명|행사명)\s*:")
DATE_LINE_RE = re.compile(r"^\s*-\s*날짜\s*:\s*")
HEADING_RE = re.compile(r"^##\s+")
ALT_LINE_RE = re.compile(r"^\s*-\s*대체\s*근거")


@dataclass(frozen=True)
class Suggestion:
    file: str
    line: int
    skipped_url: str
    alternatives: list[str]


def load_suggestions() -> list[Suggestion]:
    if not DATA.exists():
        return []
    raw = json.loads(DATA.read_text(encoding="utf-8"))
    out: list[Suggestion] = []
    for it in raw.get("items", []):
        alts = [a for a in it.get("alternatives", []) if isinstance(a, str) and a.strip()]
        if not alts:
            continue
        out.append(
            Suggestion(
                file=str(it.get("file")),
                line=int(it.get("line")),
                skipped_url=str(it.get("skipped_url")),
                alternatives=alts[:5],
            )
        )
    return out


def find_all_occurrences(lines: list[str], url: str) -> list[int]:
    idxs: list[int] = []
    for i, ln in enumerate(lines):
        if url in ln:
            idxs.append(i)
    return idxs


def in_structured_entry(lines: list[str], idx: int) -> bool:
    # Look back a bit for entry-like fields.
    start = max(0, idx - 25)
    for j in range(idx, start - 1, -1):
        if HEADING_RE.match(lines[j].strip()):
            break
        if DATE_LINE_RE.match(lines[j].strip()):
            return True
        if ENTRY_START_RE.match(lines[j].strip()):
            return True
    return False


def has_alt_nearby(lines: list[str], idx: int, window: int = 6) -> bool:
    a = max(0, idx - window)
    b = min(len(lines), idx + window + 1)
    for j in range(a, b):
        if "ALT-PROOF:" in lines[j] or ALT_LINE_RE.match(lines[j].strip()):
            return True
    return False


def apply_to_file(path: Path, suggestions: list[Suggestion]) -> bool:
    if not path.exists():
        return False

    orig = path.read_text(encoding="utf-8", errors="ignore")
    lines = orig.splitlines()
    changed = False

    # Apply suggestions in-file, by searching actual occurrences (line numbers may drift)
    for s in suggestions:
        if s.file != path.relative_to(BASE).as_posix():
            continue
        occ = find_all_occurrences(lines, s.skipped_url)
        if not occ:
            continue

        for idx in occ:
            if has_alt_nearby(lines, idx):
                continue

            alt_text = ", ".join(s.alternatives)
            if in_structured_entry(lines, idx):
                lines.insert(idx + 1, f"- 대체 근거(열리는 링크): {alt_text}")
                changed = True
            else:
                # Append comment without breaking existing markdown structure
                lines[idx] = lines[idx] + f" <!-- ALT-PROOF: {' | '.join(s.alternatives)} -->"
                changed = True

    if changed:
        path.write_text("\n".join(lines).rstrip() + "\n", encoding="utf-8")
    return changed


def main() -> None:
    suggestions = load_suggestions()
    if not suggestions:
        print("apply_alternative_proofs: no suggestions")
        return

    # Group by file for efficiency
    by_file: dict[str, list[Suggestion]] = {}
    for s in suggestions:
        by_file.setdefault(s.file, []).append(s)

    changed_files = 0
    for rel, items in sorted(by_file.items()):
        p = BASE / rel
        if apply_to_file(p, items):
            changed_files += 1

    print(f"apply_alternative_proofs: files_changed={changed_files} suggestions={len(suggestions)}")


if __name__ == "__main__":
    main()
